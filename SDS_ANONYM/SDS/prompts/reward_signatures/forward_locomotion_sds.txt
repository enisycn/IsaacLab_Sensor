Isaac Lab Reward Function Format:

Your reward function must follow this exact structure and use inline contact analysis:

def sds_custom_reward(env) -> torch.Tensor:
    # Access environment data
    robot = env.scene["robot"]
    contact_sensor = env.scene.sensors["contact_forces"]
    commands = env.command_manager.get_command("base_velocity")
    
    # Initialize reward
    reward = torch.zeros(env.num_envs, device=env.device)
    
    # IMPORTANT: For contact analysis, use this inline approach:
    # Get foot contact forces
    contact_forces = contact_sensor.data.net_forces_w  # [num_envs, num_bodies, 3]
    foot_ids, foot_names = contact_sensor.find_bodies(".*_foot")
    foot_forces = contact_forces[:, foot_ids, :]  # [num_envs, num_feet, 3]
    force_magnitudes = foot_forces.norm(dim=-1)  # [num_envs, num_feet]
    foot_contacts = force_magnitudes > 2.0  # [num_envs, num_feet] boolean tensor
    
    # Available robot data:
    # robot.data.root_pos_w[:, 2] - height (z-coordinate)
    # robot.data.root_lin_vel_b[:, 0] - forward velocity (x-axis in body frame)
    # robot.data.root_quat_w - orientation quaternion [w,x,y,z]
    # robot.data.joint_vel - joint velocities [num_envs, 12]
    
    # CRITICAL: Available contact sensor bodies for Unitree Go1:
    # ONLY these body names exist: ['FL_foot', 'FR_foot', 'RL_foot', 'RR_foot']
    # DO NOT try to find: thigh, shin, calf, hip, or any other body parts
    # ONLY use: contact_sensor.find_bodies(".*_foot") for foot contacts
    
    # CRITICAL: For tensor creation, always specify dtype and device:
    # For single vectors used with batch operations, expand to match env.num_envs:
    # up_vector = torch.tensor([0, 0, 1], dtype=torch.float32, device=env.device).expand(env.num_envs, 3)
    # projected_up = quat_apply_inverse(robot.data.root_quat_w, up_vector)
    # For batched dot products: uprightness = torch.sum(projected_up * up_vector, dim=-1)
    # 
    # NOT: torch.tensor([0, 0, 1])  # This creates Long tensors and causes errors!
    # NOT: up_vector = torch.tensor([0, 0, 1], dtype=torch.float32, device=env.device)  # Wrong shape for batch ops!
    # NOT: torch.dot(tensor1, tensor2)  # Only works with 1D tensors, not batched!
    
    # Your reward computation here
    # ...
    
    return reward

CRITICAL: Do NOT call external functions like extract_foot_contacts() or get_foot_contact_analysis().
Use the inline contact analysis code shown above.

CRITICAL: Always specify dtype=torch.float32 and device=env.device for tensor creation!